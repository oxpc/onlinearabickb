<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Virtual Arabic Keyboard for PC and Mobile">
  <title>Arabic Virtual Keyboard | ŸÑŸàÿ≠ÿ© ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</title>
  
  <style>
    /* --- Global Styles --- */
    :root {
      --primary: #2563eb;
      --primary-hover: #1d4ed8;
      --bg-color: #f1f5f9;
      --text-main: #0f172a;
      --surface: #ffffff;
      --border: #cbd5e1;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    .container {
      width: 100%;
      max-width: 900px;
      padding: 2rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      box-sizing: border-box;
    }

    header { text-align: center; }
    header h1 { margin: 0; color: var(--primary); font-size: 2rem; }
    header p { margin-top: 0.5rem; color: #64748b; }

    /* --- Editor Area --- */
    .editor {
      background: var(--surface);
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      border: 1px solid var(--border);
    }

    .toolbar {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      border-bottom: 1px solid var(--border);
      padding-bottom: 0.5rem;
    }

    button.tool-btn {
      background: transparent;
      border: 1px solid #94a3b8;
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text-main);
      font-family: inherit;
    }

    button.tool-btn:hover {
      background-color: #f8fafc;
      border-color: var(--primary);
      color: var(--primary);
    }

    button.tool-btn.primary {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    button.tool-btn.primary:hover {
      background: var(--primary-hover);
    }

    textarea {
      width: 100%;
      min-height: 150px;
      border: none;
      resize: vertical;
      font-size: 1.8rem;
      font-family: 'Times New Roman', serif; /* Standard font for Arabic */
      direction: rtl;
      padding: 0.5rem;
      box-sizing: border-box;
      outline: none;
      color: #000;
      line-height: 1.5;
    }

    footer {
      margin-top: auto;
      padding: 2rem;
      color: #64748b;
      font-size: 0.9rem;
      text-align: center;
    }
    footer a { color: var(--primary); text-decoration: none; }
  </style>
</head>

<body>

  <div class="container">
    <header>
      <h1>ŸÑŸàÿ≠ÿ© ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</h1>
      <p>Type with mouse or physical keyboard</p>
    </header>

    <div class="editor">
      <div class="toolbar">
        <button id="clearBtn" class="tool-btn" title="Clear Text">
          <span>ŸÖÿ≥ÿ≠ (Clear)</span> üóëÔ∏è
        </button>
        <button id="copyBtn" class="tool-btn primary" title="Copy to Clipboard">
          <span>ŸÜÿ≥ÿÆ (Copy)</span> üìã
        </button>
      </div>
      
      <!-- ID is 'screen' to match script logic -->
      <textarea id="screen" dir="rtl" placeholder="ÿ£ŸÉÿ™ÿ® ŸáŸÜÿß... (Type here)"></textarea>
    </div>

    <!-- The Web Component -->
    <arabic-keyboard id="kb"></arabic-keyboard>
  </div>

  <footer>
    <p>Open Source Project. <a href="https://github.com/oxpc/onlinearabickb">View on GitHub</a></p>
  </footer>

  <!-- 
    WEB COMPONENT LOGIC 
    Using Lit via CDN (No build step required)
  -->
  <script type="module">
    import { LitElement, html, css } from 'https://esm.sh/lit@3.1.2';

    // YOUR DATA STRUCTURE
    const KEY_ROWS = [
      [
        { code: 'Backquote', ar: 'ÿ∞', en: '`', shift: 'Ÿë' },
        { code: 'Digit1', ar: '1', en: '1', shift: '!' },
        { code: 'Digit2', ar: '2', en: '2', shift: '@' },
        { code: 'Digit3', ar: '3', en: '3', shift: '#' },
        { code: 'Digit4', ar: '4', en: '4', shift: '$' },
        { code: 'Digit5', ar: '5', en: '5', shift: '%' },
        { code: 'Digit6', ar: '6', en: '6', shift: '^' },
        { code: 'Digit7', ar: '7', en: '7', shift: '&' },
        { code: 'Digit8', ar: '8', en: '8', shift: '*' },
        { code: 'Digit9', ar: '9', en: '9', shift: ')' },
        { code: 'Digit0', ar: '0', en: '0', shift: '(' },
        { code: 'Minus', ar: '-', en: '-', shift: '_' },
        { code: 'Equal', ar: '=', en: '=', shift: '+' },
        { code: 'Backspace', ar: 'Backspace', label: '‚å´', type: 'action', width: 'wide' }
      ],
      [
        { code: 'Tab', ar: 'Tab', label: 'Tab', type: 'action', width: 'wide' },
        { code: 'KeyQ', ar: 'ÿ∂', en: 'q', shift: 'Ÿé' },
        { code: 'KeyW', ar: 'ÿµ', en: 'w', shift: 'Ÿã' },
        { code: 'KeyE', ar: 'ÿ´', en: 'e', shift: 'Ÿè' },
        { code: 'KeyR', ar: 'ŸÇ', en: 'r', shift: 'Ÿå' },
        { code: 'KeyT', ar: 'ŸÅ', en: 't', shift: 'ŸÑÿ•' },
        { code: 'KeyY', ar: 'ÿ∫', en: 'y', shift: 'ÿ•' },
        { code: 'KeyU', ar: 'ÿπ', en: 'u', shift: '‚Äò' },
        { code: 'KeyI', ar: 'Ÿá', en: 'i', shift: '√∑' },
        { code: 'KeyO', ar: 'ÿÆ', en: 'o', shift: '√ó' },
        { code: 'KeyP', ar: 'ÿ≠', en: 'p', shift: 'ÿõ' },
        { code: 'BracketLeft', ar: 'ÿ¨', en: '[', shift: '<' },
        { code: 'BracketRight', ar: 'ÿØ', en: ']', shift: '>' },
        { code: 'Backslash', ar: '\\', en: '\\', shift: '|' }
      ],
      [
        { code: 'CapsLock', ar: 'Caps', label: 'Caps', type: 'action', width: 'wide' },
        { code: 'KeyA', ar: 'ÿ¥', en: 'a', shift: 'Ÿê' },
        { code: 'KeyS', ar: 'ÿ≥', en: 's', shift: 'Ÿç' },
        { code: 'KeyD', ar: 'Ÿä', en: 'd', shift: ']' },
        { code: 'KeyF', ar: 'ÿ®', en: 'f', shift: '[' },
        { code: 'KeyG', ar: 'ŸÑ', en: 'g', shift: 'ŸÑÿ£' },
        { code: 'KeyH', ar: 'ÿß', en: 'h', shift: 'ÿ£' },
        { code: 'KeyJ', ar: 'ÿ™', en: 'j', shift: 'ŸÄ' },
        { code: 'KeyK', ar: 'ŸÜ', en: 'k', shift: 'ÿå' },
        { code: 'KeyL', ar: 'ŸÖ', en: 'l', shift: '/' },
        { code: 'Semicolon', ar: 'ŸÉ', en: ';', shift: ':' },
        { code: 'Quote', ar: 'ÿ∑', en: "'", shift: '"' },
        { code: 'Enter', ar: 'Enter', label: 'Enter ‚Üµ', type: 'action', width: 'extra-wide' }
      ],
      [
        { code: 'ShiftLeft', ar: 'Shift', label: 'Shift ‚áß', type: 'action', width: 'extra-wide' },
        { code: 'KeyZ', ar: 'ÿ¶', en: 'z', shift: '~' },
        { code: 'KeyX', ar: 'ÿ°', en: 'x', shift: 'Ÿí' },
        { code: 'KeyC', ar: 'ÿ§', en: 'c', shift: '}' },
        { code: 'KeyV', ar: 'ÿ±', en: 'v', shift: '{' },
        { code: 'KeyB', ar: 'ŸÑÿß', en: 'b', shift: 'ŸÑÿ¢' },
        { code: 'KeyN', ar: 'Ÿâ', en: 'n', shift: 'ÿ¢' },
        { code: 'KeyM', ar: 'ÿ©', en: 'm', shift: '‚Äô' },
        { code: 'Comma', ar: 'Ÿà', en: ',', shift: ',' },
        { code: 'Period', ar: 'ÿ≤', en: '.', shift: '.' },
        { code: 'Slash', ar: 'ÿ∏', en: '/', shift: 'ÿü' },
        { code: 'ShiftRight', ar: 'Shift', label: 'Shift ‚áß', type: 'action', width: 'extra-wide' }
      ],
      [
        { code: 'Space', ar: ' ', label: ' ', type: 'char', width: 'spacebar' }
      ]
    ];

    export class ArabicKeyboard extends LitElement {
      static properties = {
        showShiftedValue: { type: Boolean },
        showEnglishValue: { type: Boolean },
        _shiftActive: { state: true },
        _capsActive: { state: true }
      };

      static styles = css`
        :host {
          display: block;
          --k-bg: #ffffff;
          --k-text: #1f2937;
          --k-sub: #94a3b8;
          --k-accent: #2563eb;
          --k-board: #e2e8f0;
          --k-shadow: #94a3b8;
          
          background-color: var(--k-board);
          padding: 10px;
          border-radius: 12px;
          user-select: none;
          box-shadow: inset 0 -4px 0 rgba(0,0,0,0.05);
          direction: ltr;
        }

        .keyboard {
          display: flex;
          flex-direction: column;
          gap: 6px;
        }

        .row {
          display: flex;
          gap: 6px;
          justify-content: center;
        }

        button {
          position: relative;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          background-color: var(--k-bg);
          color: var(--k-text);
          border: 1px solid transparent;
          border-radius: 6px;
          min-width: 45px;
          height: 50px;
          cursor: pointer;
          box-shadow: 0 4px 0 var(--k-shadow);
          transition: all 0.1s ease;
          font-family: inherit;
          -webkit-tap-highlight-color: transparent;
          padding: 0;
        }

        /* State: Pressed (Visual) */
        button:active, button.pressed {
          transform: translateY(4px);
          box-shadow: 0 0 0 var(--k-shadow);
          background-color: #f1f5f9;
        }

        /* State: Toggled (Caps/Shift) */
        button.active {
          background-color: #dbeafe;
          border-color: var(--k-accent);
          color: var(--k-accent);
          transform: translateY(2px);
          box-shadow: 0 2px 0 var(--k-shadow);
        }

        /* Width Classes based on your structure */
        .wide { flex-grow: 1; max-width: 80px; font-size: 0.9em; font-weight: bold; }
        .extra-wide { flex-grow: 1.5; max-width: 110px; font-size: 0.9em; font-weight: bold;}
        .spacebar { flex-grow: 5; max-width: 400px; }

        /* Typography */
        .main { font-size: 1.3rem; font-weight: 600; line-height: 1; margin-top: 2px;}
        .en { position: absolute; top: 3px; left: 5px; font-size: 0.65rem; color: var(--k-sub); font-weight: bold; }
        .shift { position: absolute; top: 3px; right: 5px; font-size: 0.75rem; color: var(--k-accent); }

        @media (max-width: 600px) {
          :host { padding: 5px; }
          .keyboard { gap: 4px; }
          .row { gap: 3px; }
          button { min-width: 8%; height: 45px; border-radius: 4px; box-shadow: 0 2px 0 var(--k-shadow); }
          button:active, button.pressed { transform: translateY(2px); }
          .en, .shift { font-size: 0.5rem; top: 2px; }
          .main { font-size: 1rem; }
          .wide, .extra-wide { font-size: 0.7em; }
        }
      `;

      constructor() {
        super();
        this.showShiftedValue = true;
        this.showEnglishValue = true;
        this._shiftActive = false;
        this._capsActive = false;
        this._keyMap = new Map();

        // Build a lookup map for physical keyboard support
        KEY_ROWS.flat().forEach(k => {
          if (k.code) this._keyMap.set(k.code, k);
        });

        // Binding to avoid reference issues
        this._boundKeyDown = this._onPhysicalKeyDown.bind(this);
        this._boundKeyUp = this._onPhysicalKeyUp.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        window.addEventListener('keydown', this._boundKeyDown);
        window.addEventListener('keyup', this._boundKeyUp);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener('keydown', this._boundKeyDown);
        window.removeEventListener('keyup', this._boundKeyUp);
      }

      // 1. Listen for Physical Key Down
      _onPhysicalKeyDown(e) {
        // Prevent typing if we aren't focused on the screen, 
        // BUT also allow typing if body is focused (so user can just start typing)
        const active = document.activeElement;
        const isScreen = active && active.id === 'screen';
        
        // Allow shortcut keys (Ctrl/Cmd) to pass through
        if (e.ctrlKey || e.metaKey || e.altKey) return;

        const keyData = this._keyMap.get(e.code);
        if (keyData) {
          e.preventDefault(); // Stop English char from appearing
          this._handleInput(keyData);
          
          // Add visual press effect
          const btn = this.shadowRoot.querySelector(`button[data-code="${e.code}"]`);
          if (btn) btn.classList.add('pressed');
        }
      }

      // 2. Listen for Physical Key Up (Remove visual press)
      _onPhysicalKeyUp(e) {
        const btn = this.shadowRoot.querySelector(`button[data-code="${e.code}"]`);
        if (btn) btn.classList.remove('pressed');
        
        // Handle physical shift release (unless CapsLock logic is preferred)
        if (e.code.includes('Shift')) {
           // We keep shift active if it was toggled via click, but for physical keys,
           // we usually want it to release. However, to match virtual behavior:
           // If physical shift is released, we ensure internal state matches.
           // For simplicity in mixed usage, we might leave it toggled or reset it.
           // Let's reset it to mimic a real keyboard behavior.
           this._shiftActive = false;
        }
      }

      // 3. Central Input Handler
      _handleInput(key) {
        let char = key.ar; // Default Arabic char
        let action = null;

        if (key.type === 'action') {
          // Map codes to action strings for the main script
          if (key.code === 'Backspace') action = 'delete';
          else if (key.code === 'Enter') action = 'enter';
          else if (key.code === 'Tab') action = 'tab';
          
          // Modifiers
          else if (key.code.includes('Shift')) {
            this._shiftActive = !this._shiftActive;
            return; // Don't emit event for modifier toggle
          }
          else if (key.code === 'CapsLock') {
            this._capsActive = !this._capsActive;
            return;
          }
        } else {
          // It's a character key
          if (this._shiftActive && key.shift) {
            char = key.shift;
            if (!this._capsActive) this._shiftActive = false; // Release shift after 1 char
          }
        }

        // Dispatch to parent
        this.dispatchEvent(new CustomEvent('kb-input', {
          detail: { char: action ? null : char, action },
          bubbles: true,
          composed: true
        }));
      }

      render() {
        return html`
          <div class="keyboard">
            ${KEY_ROWS.map(row => html`
              <div class="row">
                ${row.map(key => this._renderKey(key))}
              </div>
            `)}
          </div>
        `;
      }

      _renderKey(key) {
        // Check if button should look "Active/Toggled"
        const isShiftKey = key.code.includes('Shift');
        const isCapsKey = key.code === 'CapsLock';
        const isActive = (isShiftKey && this._shiftActive) || (isCapsKey && this._capsActive);
        
        // Determine main display label
        let display = key.ar;
        if (key.type === 'action' && key.label) display = key.label;
        if (key.type !== 'action' && this._shiftActive && key.shift) display = key.shift;

        return html`
          <button 
            data-code="${key.code}"
            class="${key.width || ''} ${isActive ? 'active' : ''}" 
            @click="${(e) => { 
              e.preventDefault(); 
              // For virtual clicks, we might want to focus textarea so typing continues
              document.getElementById('screen')?.focus();
              this._handleInput(key); 
            }}"
          >
            <span class="main">${display}</span>
            ${this.showEnglishValue && key.type !== 'action' && key.en ? html`<span class="en">${key.en}</span>` : ''}
            ${this.showShiftedValue && key.type !== 'action' && key.shift ? html`<span class="shift">${key.shift}</span>` : ''}
          </button>
        `;
      }
    }

    customElements.define('arabic-keyboard', ArabicKeyboard);
  </script>

  <!-- APPLICATION LOGIC (Clipboard, Text Manipulation) -->
  <script>
    const textarea = document.getElementById('screen');
    const kb = document.getElementById('kb');
    const copyBtn = document.getElementById('copyBtn');
    const clearBtn = document.getElementById('clearBtn');

    // 1. Listen for custom events from the component
    kb.addEventListener('kb-input', (e) => {
      const { char, action } = e.detail;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      
      textarea.focus();

      if (action === 'delete') {
        if (start === end && start > 0) {
          // Delete character before cursor
          textarea.setRangeText('', start - 1, end, 'end');
        } else {
          // Delete selected text
          textarea.setRangeText('', start, end, 'end');
        }
      } else if (action === 'enter') {
        textarea.setRangeText('\n', start, end, 'end');
      } else if (action === 'tab') {
        textarea.setRangeText('\t', start, end, 'end');
      } else if (char) {
        // Insert character
        textarea.setRangeText(char, start, end, 'end');
      }
    });

    // 2. Copy Functionality
    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(textarea.value);
        const original = copyBtn.innerHTML;
        copyBtn.innerHTML = '<span>ÿ™ŸÖ ÿßŸÑŸÜÿ≥ÿÆ!</span> ‚úÖ';
        setTimeout(() => copyBtn.innerHTML = original, 1500);
      } catch (err) {
        alert("Could not copy text.");
      }
    });

    // 3. Clear Functionality
    clearBtn.addEventListener('click', () => {
      if(textarea.value.length > 0 && confirm("Clear text?")) {
        textarea.value = '';
        textarea.focus();
      }
    });
  </script>
</body>
</html>
